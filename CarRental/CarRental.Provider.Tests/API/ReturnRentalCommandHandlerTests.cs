using Ardalis.Result;
using Ardalis.Specification;
using AutoMapper;
using CarRental.Common.Core.Enums;
using CarRental.Common.Core.ProviderEntities;
using CarRental.Provider.API.DTOs.Rentals;
using CarRental.Provider.API.Requests.Rentals.Commands;
using CarRental.Provider.API.Requests.Rentals.Handlers;
using CarRental.Provider.Infrastructure.EmailServices;
using CarRental.Provider.Persistence.Specifications.Rentals;
using CarRental.Provider.Tests.Dummies;
using FluentAssertions;
using Moq;

namespace CarRental.Provider.Tests.API;
public sealed class ReturnRentalCommandHandlerTests
{
	private readonly Mock<IRepositoryBase<Rental>> rentalsRepositoryMock;
	private readonly Mock<IMapper> mapperMock;
	private readonly Mock<IEmailInputMaker> emailInputMakerMock;
	private readonly Mock<IEmailService> emailServiceMock;
	private readonly ReturnRentalCommandHandler handler;

	public ReturnRentalCommandHandlerTests()
	{
		rentalsRepositoryMock = new();
		mapperMock = new();
		emailInputMakerMock = new();
		emailServiceMock = new();

		handler = new ReturnRentalCommandHandler(
			rentalsRepositoryMock.Object,
			mapperMock.Object,
			emailInputMakerMock.Object,
			emailServiceMock.Object
		);
	}

	[Fact]
	public async Task Handle_WhenRentalDoesNotExist_ShouldReturnNotFound()
	{
		// Arrange
		var command = new ReturnRentalCommand(Id: default, Audience: string.Empty);

		// Act
		var result = await handler.Handle(command, CancellationToken.None);

		// Assert
		result.Status.Should().Be(ResultStatus.NotFound);
	}

	[Fact]
	public async Task Handle_WhenRentalAudienceDoesNotMatch_ShouldReturnForbidden()
	{
		// Arrange
		var command = new ReturnRentalCommand(Id: default, Audience: "DifferentAudience");
		var rental = ProviderEntitiesDummyFactory.CreateRentalDummy();

		rental.Offer.GeneratedBy = "TestAudience";

		rentalsRepositoryMock
			.Setup(r => r.FirstOrDefaultAsync(
				It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
				It.IsAny<CancellationToken>()))
			.ReturnsAsync(rental);

		// Act
		var result = await handler.Handle(command, CancellationToken.None);

		// Assert
		rentalsRepositoryMock.Verify(r => r.FirstOrDefaultAsync(
			It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
			It.IsAny<CancellationToken>()),
			Times.Once
		);

		rentalsRepositoryMock.VerifyNoOtherCalls();

		result.Status.Should().Be(ResultStatus.Forbidden);
		result.Errors.Should().Contain("Offer associated with rental was generated by a different audience.");
	}

	[Fact]
	public async Task Handle_WhenRentalIsReadyForReturn_ShouldReturnSuccess()
	{
		// Arrange
		var command = new ReturnRentalCommand(Id: default, Audience: string.Empty);
		var rental = ProviderEntitiesDummyFactory.CreateRentalDummy();

		rental.Status = RentalStatus.ReadyForReturn;

		rentalsRepositoryMock
			.Setup(r => r.FirstOrDefaultAsync(
				It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
				It.IsAny<CancellationToken>()))
			.ReturnsAsync(rental);

		// Act
		var result = await handler.Handle(command, CancellationToken.None);

		// Assert
		rentalsRepositoryMock.Verify(r => r.FirstOrDefaultAsync(
			It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
			It.IsAny<CancellationToken>()),
			Times.Once
		);

		rentalsRepositoryMock.VerifyNoOtherCalls();

		result.Status.Should().Be(ResultStatus.Ok);
	}

	[Fact]
	public async Task Handle_WhenRentalIsNotActiveAndNotReadyForReturn_ShouldReturnInvalid()
	{
		// Arrange
		var command = new ReturnRentalCommand(Id: default, Audience: string.Empty);
		var rental = ProviderEntitiesDummyFactory.CreateRentalDummy();

		rental.Status = RentalStatus.Unconfirmed;

		rentalsRepositoryMock
			.Setup(r => r.FirstOrDefaultAsync(
				It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
				It.IsAny<CancellationToken>()))
			.ReturnsAsync(rental);

		// Act
		var result = await handler.Handle(command, CancellationToken.None);

		// Assert
		rentalsRepositoryMock.Verify(r => r.FirstOrDefaultAsync(
			It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
			It.IsAny<CancellationToken>()),
			Times.Once
		);

		rentalsRepositoryMock.VerifyNoOtherCalls();

		result.Status.Should().Be(ResultStatus.Invalid);
		result.ValidationErrors.Should().ContainSingle(e => e.Identifier == nameof(Rental.Status));
	}

	[Fact]
	public async Task Handle_WhenRentalIsSetToReadyForReturn_ShouldSendEmailAndReturnSuccess()
	{
		// Arrange
		var command = new ReturnRentalCommand(Id: default, Audience: string.Empty);
		var rental = ProviderEntitiesDummyFactory.CreateRentalDummy();

		rental.Status = RentalStatus.Active;
		rental.Offer.Car.Model.Name = "ModelName";
		rental.Offer.Car.Model.Make.Name = "MakeName";
		rental.Customer = new Customer()
		{
			FirstName = "FirstName",
			LastName = "LastName",
			EmailAddress = "customer@example.com"
		};

		var rentalDto = new RentalStatusDto(Id: default, Status: RentalStatus.ReadyForReturn);

		rentalsRepositoryMock
			.Setup(r => r.FirstOrDefaultAsync(
				It.IsAny<RentalByIdWithOfferCarModelMakeClientSpecification>(),
				It.IsAny<CancellationToken>()))
			.ReturnsAsync(rental);

		mapperMock
			.Setup(mapper => mapper.Map<RentalStatusDto>(rental))
			.Returns(rentalDto);

		// Act
		var result = await handler.Handle(command, CancellationToken.None);

		// Assert
		rentalsRepositoryMock.Verify(r => r.UpdateAsync(rental, It.IsAny<CancellationToken>()), Times.Once);
		rentalsRepositoryMock.Verify(r => r.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once);
		emailServiceMock.Verify(e => e.SendEmailAsync(It.IsAny<SendEmailInput>()), Times.Once);

		result.Status.Should().Be(ResultStatus.Ok);
		result.Value.Should().BeEquivalentTo(rentalDto);
	}
}